{"version":3,"file":"index.js","sources":["../node_modules/tslib/tslib.es6.js","../src/types.ts","../src/Provider.tsx","../src/unique-id.ts","../src/use-roving-tabindex.ts","../src/use-focus-effect.ts"],"sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nexport function __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, privateMap) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to get private field on non-instance\");\r\n    }\r\n    return privateMap.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, privateMap, value) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to set private field on non-instance\");\r\n    }\r\n    privateMap.set(receiver, value);\r\n    return value;\r\n}\r\n","export enum EventKey {\n  ArrowLeft = \"ArrowLeft\",\n  ArrowRight = \"ArrowRight\",\n  ArrowUp = \"ArrowUp\",\n  ArrowDown = \"ArrowDown\",\n  Home = \"Home\",\n  End = \"End\"\n}\n\nexport type KeyDirection = \"horizontal\" | \"vertical\" | \"both\";\n\nexport enum Navigation {\n  PREVIOUS = \"PREVIOUS\",\n  NEXT = \"NEXT\",\n  VERY_FIRST = \"VERY_FIRST\",\n  VERY_LAST = \"VERY_LAST\",\n  PREVIOUS_ROW = \"PREVIOUS_ROW\",\n  NEXT_ROW = \"NEXT_ROW\",\n  FIRST_IN_ROW = \"FIRST_IN_ROW\",\n  LAST_IN_ROW = \"LAST_IN_ROW\"\n}\n\nexport type TabStop = Readonly<{\n  id: string;\n  domElementRef: React.RefObject<Element>;\n  disabled: boolean;\n  rowIndex: number | null;\n}>;\n\nexport type RowStartMap = Map<Exclude<TabStop[\"rowIndex\"], null>, number>;\n\nexport type State = Readonly<{\n  selectedId: string | null;\n  allowFocusing: boolean;\n  tabStops: readonly TabStop[];\n  direction: KeyDirection;\n  rowStartMap: RowStartMap | null;\n}>;\n\nexport enum ActionType {\n  REGISTER_TAB_STOP = \"REGISTER_TAB_STOP\",\n  UNREGISTER_TAB_STOP = \"UNREGISTER_TAB_STOP\",\n  KEY_DOWN = \"KEY_DOWN\",\n  CLICKED = \"CLICKED\",\n  TAB_STOP_UPDATED = \"TAB_STOP_UPDATED\",\n  DIRECTION_UPDATED = \"DIRECTION_UPDATED\"\n}\n\nexport type Action =\n  | {\n      type: ActionType.REGISTER_TAB_STOP;\n      payload: TabStop;\n    }\n  | {\n      type: ActionType.UNREGISTER_TAB_STOP;\n      payload: { id: TabStop[\"id\"] };\n    }\n  | {\n      type: ActionType.TAB_STOP_UPDATED;\n      payload: {\n        id: TabStop[\"id\"];\n        rowIndex: TabStop[\"rowIndex\"];\n        disabled: TabStop[\"disabled\"];\n      };\n    }\n  | {\n      type: ActionType.KEY_DOWN;\n      payload: {\n        id: TabStop[\"id\"];\n        key: EventKey;\n        ctrlKey: boolean;\n      };\n    }\n  | {\n      type: ActionType.CLICKED;\n      payload: { id: TabStop[\"id\"] };\n    }\n  | {\n      type: ActionType.DIRECTION_UPDATED;\n      payload: { direction: KeyDirection };\n    };\n\nexport type Context = Readonly<{\n  state: State;\n  dispatch: React.Dispatch<Action>;\n}>;\n\nexport type HookResponse = [\n  number,\n  boolean,\n  (event: React.KeyboardEvent) => void,\n  () => void,\n  string | null\n];\n","import React, {\n  useMemo,\n  useEffect,\n  createContext,\n  useReducer,\n  ReactElement,\n  ReactNode\n} from \"react\";\nimport warning from \"warning\";\nimport {\n  Action,\n  ActionType,\n  Context,\n  EventKey,\n  KeyDirection,\n  Navigation,\n  RowStartMap,\n  State,\n  TabStop\n} from \"./types\";\n\nconst DOCUMENT_POSITION_FOLLOWING = 4;\n\n// Note: The `allowFocusing` state property is required\n// to delay focusing of the selected tab stop\n// DOM element until the user has started interacting\n// with the roving tabindex's controls. If this delay\n// did not occur, the selected control would be focused\n// as soon as it was mounted, which is unlikely to be\n// the desired behaviour for the page.\n//\n// Note: The rowStartMap is only created if row-related\n// navigation occurs (e.g., move to row start or end), so\n// non-grid usage of this library does not pay the price\n// (minimal as it is) of constructing this map. The map\n// gets cleared if registering, unregistering, or updating.\nexport function reducer(state: State, action: Action): State {\n  switch (action.type) {\n    case ActionType.REGISTER_TAB_STOP: {\n      const newTabStop = action.payload;\n      if (!newTabStop.domElementRef.current) {\n        return state;\n      }\n\n      // Iterate backwards through state.tabStops since it is\n      // most likely that the tab stop will need to be inserted\n      // at the end of that array.\n      let indexToInsertAt = -1;\n      for (let i = state.tabStops.length - 1; i >= 0; --i) {\n        const loopTabStop = state.tabStops[i];\n        if (loopTabStop.id === newTabStop.id) {\n          warning(false, `'${newTabStop.id}' tab stop already registered`);\n          return state;\n        }\n        // The compareDocumentPosition condition is true\n        // if newTabStop follows loopTabStop:\n        if (\n          indexToInsertAt === -1 &&\n          loopTabStop.domElementRef.current &&\n          !!(\n            loopTabStop.domElementRef.current.compareDocumentPosition(\n              newTabStop.domElementRef.current\n            ) & DOCUMENT_POSITION_FOLLOWING\n          )\n        ) {\n          indexToInsertAt = i + 1;\n          break;\n        }\n      }\n\n      // The indexToInsertAt is -1 when newTabStop should be inserted\n      // at the start of tabStops (the compareDocumentPosition condition\n      // always returns false in that case).\n      if (indexToInsertAt === -1) {\n        indexToInsertAt = 0;\n      }\n\n      const newTabStops = state.tabStops.slice();\n      newTabStops.splice(indexToInsertAt, 0, newTabStop);\n\n      return {\n        ...state,\n        selectedId: getUpdatedSelectedId(newTabStops, state.selectedId),\n        tabStops: newTabStops,\n        rowStartMap: null\n      };\n    }\n    case ActionType.UNREGISTER_TAB_STOP: {\n      const id = action.payload.id;\n      const newTabStops = state.tabStops.filter((tabStop) => tabStop.id !== id);\n      if (newTabStops.length === state.tabStops.length) {\n        warning(false, `'${id}' tab stop already unregistered`);\n        return state;\n      }\n      return {\n        ...state,\n        selectedId: getUpdatedSelectedId(newTabStops, state.selectedId),\n        tabStops: newTabStops,\n        rowStartMap: null\n      };\n    }\n    case ActionType.TAB_STOP_UPDATED: {\n      const { id, rowIndex, disabled } = action.payload;\n      const index = state.tabStops.findIndex((tabStop) => tabStop.id === id);\n      if (index === -1) {\n        warning(false, `'${id}' tab stop not registered`);\n        return state;\n      }\n\n      const tabStop = state.tabStops[index];\n      if (tabStop.disabled === disabled && tabStop.rowIndex === rowIndex) {\n        // Nothing to do so short-circuit.\n        return state;\n      }\n\n      const newTabStop = { ...tabStop, rowIndex, disabled };\n      const newTabStops = state.tabStops.slice();\n      newTabStops.splice(index, 1, newTabStop);\n\n      return {\n        ...state,\n        selectedId: getUpdatedSelectedId(newTabStops, state.selectedId),\n        tabStops: newTabStops,\n        rowStartMap: null\n      };\n    }\n    case ActionType.KEY_DOWN: {\n      const { id, key, ctrlKey } = action.payload;\n      const index = state.tabStops.findIndex((tabStop) => tabStop.id === id);\n      if (index === -1) {\n        warning(false, `'${id}' tab stop not registered`);\n        return state;\n      }\n      const currentTabStop = state.tabStops[index];\n      if (currentTabStop.disabled) {\n        return state;\n      }\n      const isGrid = currentTabStop.rowIndex !== null;\n      const navigation = getNavigationValue(\n        key,\n        ctrlKey,\n        isGrid,\n        state.direction\n      );\n      if (!navigation) {\n        return state;\n      }\n\n      switch (navigation) {\n        case Navigation.NEXT:\n          {\n            for (let i = index + 1; i < state.tabStops.length; ++i) {\n              const tabStop = state.tabStops[i];\n              if (isGrid && tabStop.rowIndex !== currentTabStop.rowIndex) {\n                break;\n              }\n              if (!tabStop.disabled) {\n                return selectTabStop(state, tabStop);\n              }\n            }\n          }\n          break;\n        case Navigation.PREVIOUS:\n          {\n            for (let i = index - 1; i >= 0; --i) {\n              const tabStop = state.tabStops[i];\n              if (isGrid && tabStop.rowIndex !== currentTabStop.rowIndex) {\n                break;\n              }\n              if (!tabStop.disabled) {\n                return selectTabStop(state, tabStop);\n              }\n            }\n          }\n          break;\n        case Navigation.VERY_FIRST:\n          {\n            for (let i = 0; i < state.tabStops.length; ++i) {\n              const tabStop = state.tabStops[i];\n              if (!tabStop.disabled) {\n                return selectTabStop(state, tabStop);\n              }\n            }\n          }\n          break;\n        case Navigation.VERY_LAST:\n          {\n            for (let i = state.tabStops.length - 1; i >= 0; --i) {\n              const tabStop = state.tabStops[i];\n              if (!tabStop.disabled) {\n                return selectTabStop(state, tabStop);\n              }\n            }\n          }\n          break;\n        case Navigation.PREVIOUS_ROW:\n          {\n            if (\n              currentTabStop.rowIndex === null ||\n              currentTabStop.rowIndex === 0\n            ) {\n              return state;\n            }\n            const rowStartMap = state.rowStartMap || createRowStartMap(state);\n            const rowStartIndex = rowStartMap.get(currentTabStop.rowIndex);\n            if (rowStartIndex === undefined) {\n              return state;\n            }\n            const columnOffset = index - rowStartIndex;\n            for (let i = currentTabStop.rowIndex - 1; i >= 0; --i) {\n              const rowStartIndex = rowStartMap.get(i);\n              if (rowStartIndex === undefined) {\n                return state;\n              }\n              const rowTabStop = state.tabStops[rowStartIndex + columnOffset];\n              if (!rowTabStop.disabled) {\n                return selectTabStop(state, rowTabStop, rowStartMap);\n              }\n            }\n            return { ...state, allowFocusing: true, rowStartMap };\n          }\n          break;\n        case Navigation.NEXT_ROW:\n          {\n            const maxRowIndex =\n              state.tabStops[state.tabStops.length - 1].rowIndex;\n            if (\n              currentTabStop.rowIndex === null ||\n              maxRowIndex === null ||\n              currentTabStop.rowIndex === maxRowIndex\n            ) {\n              return state;\n            }\n            const rowStartMap = state.rowStartMap || createRowStartMap(state);\n            const rowStartIndex = rowStartMap.get(currentTabStop.rowIndex);\n            if (rowStartIndex === undefined) {\n              return state;\n            }\n            const columnOffset = index - rowStartIndex;\n            for (let i = currentTabStop.rowIndex + 1; i <= maxRowIndex; ++i) {\n              const rowStartIndex = rowStartMap.get(i);\n              if (rowStartIndex === undefined) {\n                return state;\n              }\n              const rowTabStop = state.tabStops[rowStartIndex + columnOffset];\n              if (!rowTabStop.disabled) {\n                return selectTabStop(state, rowTabStop, rowStartMap);\n              }\n            }\n            return { ...state, allowFocusing: true, rowStartMap };\n          }\n          break;\n        case Navigation.FIRST_IN_ROW:\n          {\n            if (currentTabStop.rowIndex === null) {\n              return state;\n            }\n            const rowStartMap = state.rowStartMap || createRowStartMap(state);\n            const rowStartIndex = rowStartMap.get(currentTabStop.rowIndex);\n            if (rowStartIndex === undefined) {\n              return state;\n            }\n            for (let i = rowStartIndex; i < state.tabStops.length; ++i) {\n              const tabStop = state.tabStops[i];\n              if (tabStop.rowIndex !== currentTabStop.rowIndex) {\n                break;\n              } else if (!tabStop.disabled) {\n                return selectTabStop(state, state.tabStops[i], rowStartMap);\n              }\n            }\n          }\n          break;\n        case Navigation.LAST_IN_ROW:\n          {\n            if (currentTabStop.rowIndex === null) {\n              return state;\n            }\n            const rowStartMap = state.rowStartMap || createRowStartMap(state);\n            const rowEndIndex = rowStartMap.has(currentTabStop.rowIndex + 1)\n              ? (rowStartMap.get(currentTabStop.rowIndex + 1) || 0) - 1\n              : state.tabStops.length - 1;\n            for (let i = rowEndIndex; i >= 0; --i) {\n              const tabStop = state.tabStops[i];\n              if (tabStop.rowIndex !== currentTabStop.rowIndex) {\n                break;\n              } else if (!tabStop.disabled) {\n                return selectTabStop(state, state.tabStops[i], rowStartMap);\n              }\n            }\n          }\n          break;\n      }\n      return state;\n    }\n    case ActionType.CLICKED: {\n      const id = action.payload.id;\n      const index = state.tabStops.findIndex((tabStop) => tabStop.id === id);\n      if (index === -1) {\n        warning(false, `'${id}' tab stop not registered`);\n        return state;\n      }\n      const currentTabStop = state.tabStops[index];\n      return currentTabStop.disabled\n        ? state\n        : selectTabStop(state, currentTabStop);\n    }\n    case ActionType.DIRECTION_UPDATED: {\n      const direction = action.payload.direction;\n      return direction === state.direction ? state : { ...state, direction };\n    }\n    default:\n      return state;\n  }\n}\n\n// Determine the updated value for selectedId:\nfunction getUpdatedSelectedId(\n  tabStops: State[\"tabStops\"],\n  currentSelectedId: State[\"selectedId\"]\n): State[\"selectedId\"] {\n  if (currentSelectedId === null) {\n    // There is not currently selected tab stop, so find\n    // the first tab stop that is not disabled and return\n    // its id, otherwise return null.\n    const index = tabStops.findIndex((tabStop) => !tabStop.disabled);\n    return index === -1 ? null : tabStops[index].id;\n  }\n\n  let index = tabStops.findIndex((tabStop) => tabStop.id === currentSelectedId);\n  if (index !== -1 && !tabStops[index].disabled) {\n    // The current selected id is still valid, so return it.\n    return currentSelectedId;\n  }\n\n  // Finds the first tab stop that is not disabled and return\n  // its id, otherwise return null.\n  index = tabStops.findIndex((tabStop) => !tabStop.disabled);\n  return index === -1 ? null : tabStops[index].id;\n}\n\n// Translates the user key down event info into a navigation instruction.\nfunction getNavigationValue(\n  key: EventKey,\n  ctrlKey: boolean,\n  isGrid: boolean,\n  direction: string\n): Navigation | null {\n  switch (key) {\n    case EventKey.ArrowLeft:\n      return isGrid || direction === \"horizontal\" || direction === \"both\"\n        ? Navigation.PREVIOUS\n        : null;\n    case EventKey.ArrowRight:\n      return isGrid || direction === \"horizontal\" || direction === \"both\"\n        ? Navigation.NEXT\n        : null;\n    case EventKey.ArrowUp:\n      if (isGrid) {\n        return Navigation.PREVIOUS_ROW;\n      } else {\n        return direction === \"vertical\" || direction === \"both\"\n          ? Navigation.PREVIOUS\n          : null;\n      }\n    case EventKey.ArrowDown:\n      if (isGrid) {\n        return Navigation.NEXT_ROW;\n      } else {\n        return direction === \"vertical\" || direction === \"both\"\n          ? Navigation.NEXT\n          : null;\n      }\n    case EventKey.Home:\n      return !isGrid || ctrlKey\n        ? Navigation.VERY_FIRST\n        : Navigation.FIRST_IN_ROW;\n    case EventKey.End:\n      return !isGrid || ctrlKey ? Navigation.VERY_LAST : Navigation.LAST_IN_ROW;\n    default:\n      return null;\n  }\n}\n\n// Creates the new state for a tab stop when it becomes the selected one.\nfunction selectTabStop(\n  state: State,\n  tabStop: TabStop,\n  rowStartMap?: RowStartMap\n) {\n  return {\n    ...state,\n    allowFocusing: true,\n    selectedId: tabStop.id,\n    rowStartMap: rowStartMap || state.rowStartMap\n  };\n}\n\n// Creates the row start index lookup map\n// for the currently registered tab stops.\nfunction createRowStartMap(state: State) {\n  const map: RowStartMap = new Map();\n  for (let i = 0; i < state.tabStops.length; ++i) {\n    const { rowIndex } = state.tabStops[i];\n    if (rowIndex !== null && !map.has(rowIndex)) {\n      map.set(rowIndex, i);\n    }\n  }\n  return map;\n}\n\nconst INITIAL_STATE: State = {\n  selectedId: null,\n  allowFocusing: false,\n  tabStops: [],\n  direction: \"horizontal\",\n  rowStartMap: null\n};\n\nexport const RovingTabIndexContext = createContext<Context>({\n  state: INITIAL_STATE,\n  // eslint-disable-next-line @typescript-eslint/no-empty-function\n  dispatch: () => {}\n});\n\n/**\n * Creates a roving tabindex context.\n * @param {ReactNode} children The child content, which will\n * include the DOM elements to rove between using the tab key.\n * @param {KeyDirection} direction An optional direction value\n * that only applies when the roving tabindex is not being\n * used within a grid. This value specifies the arrow key behaviour.\n * When set to 'horizontal' then only the ArrowLeft and ArrowRight\n * keys move to the previous and next tab stop respectively.\n * When set to 'vertical' then only the ArrowUp and ArrowDown keys\n * move to the previous and next tab stop respectively. When set\n * to 'both' then both the ArrowLeft and ArrowUp keys can be used\n * to move to the previous tab stop, and both the ArrowRight\n * and ArrowDown keys can be used to move to the next tab stop.\n * If you do not pass an explicit value then the 'horizontal'\n * behaviour applies. You can change this direction value\n * at any time.\n */\nexport const Provider = ({\n  children,\n  direction = \"horizontal\"\n}: {\n  children: ReactNode;\n  direction?: KeyDirection;\n}): ReactElement => {\n  const [state, dispatch] = useReducer(reducer, {\n    ...INITIAL_STATE,\n    direction\n  });\n\n  // Update the direction whenever it changes:\n  useEffect(() => {\n    dispatch({ type: ActionType.DIRECTION_UPDATED, payload: { direction } });\n  }, [direction]);\n\n  // Create a cached object to use as the context value:\n  const context = useMemo<Context>(() => ({ state, dispatch }), [state]);\n\n  return (\n    <RovingTabIndexContext.Provider value={context}>\n      {children}\n    </RovingTabIndexContext.Provider>\n  );\n};\n","let counter = 0;\n\nexport function uniqueId(): string {\n  return `rti_${++counter}`;\n}\n","import {\n  useCallback,\n  useRef,\n  useContext,\n  useEffect,\n  RefObject,\n  KeyboardEvent\n} from \"react\";\nimport { RovingTabIndexContext } from \"./Provider\";\nimport { ActionType, EventKey, HookResponse } from \"./types\";\nimport { uniqueId } from \"./unique-id\";\n\n/**\n * Includes the given DOM element in the current roving tabindex.\n * @param {RefObject<Element>} domElementRef The DOM element to include.\n * This must be the same DOM element for the lifetime of the containing\n * component.\n * @param {boolean} disabled Whether or not the DOM element is currently\n * enabled. This value can be updated as appropriate throughout the lifetime\n * of the containing component.\n * @param {number?} rowIndex An optional integer value that must be\n * populated if the roving tabindex is being used in a grid. In that case,\n * set it to the zero-based index of the row that the given DOM element\n * is currently part of. You can update this row index as appropriate\n * throughout the lifetime of the containing component, for example if\n * the shape of the grid can change dynamically.\n * @returns A tuple of values to be applied by the containing\n * component for the roving tabindex to work correctly.\n * First tuple value: The tabIndex value to apply to the tab stop\n * element.\n * Second tuple value: Whether or not focus() should be invoked on the\n * tab stop element.\n * Third tuple value: The onKeyDown callback to apply to the tab\n * stop element. If the key press is relevant to the hook then\n * event.preventDefault() will be invoked on the event.\n * Fourth tuple value: The onClick callback to apply to the tab\n * stop element.\n */\nexport function useRovingTabIndex(\n  domElementRef: RefObject<Element>,\n  disabled: boolean,\n  rowIndex: number | null = null\n): HookResponse {\n  // Create a stable ID for the lifetime of the component:\n  const idRef = useRef<string | null>(null);\n\n  function getId() {\n    if (!idRef.current) {\n      idRef.current = uniqueId();\n    }\n    return idRef.current;\n  }\n\n  const isMounted = useRef(false);\n  const context = useContext(RovingTabIndexContext);\n\n  // Register the tab stop on mount and unregister it on unmount:\n  useEffect(() => {\n    const id = getId();\n    context.dispatch({\n      type: ActionType.REGISTER_TAB_STOP,\n      payload: {\n        id,\n        domElementRef,\n        rowIndex,\n        disabled\n      }\n    });\n    return (): void => {\n      context.dispatch({\n        type: ActionType.UNREGISTER_TAB_STOP,\n        payload: { id }\n      });\n    };\n  }, []);\n\n  // Update the tab stop data if rowIndex or disabled change.\n  // The isMounted flag is used to prevent this effect running\n  // on mount, which is benign but redundant (as the\n  // REGISTER_TAB_STOP action would have just been dispatched).\n  useEffect(() => {\n    if (isMounted.current) {\n      context.dispatch({\n        type: ActionType.TAB_STOP_UPDATED,\n        payload: {\n          id: getId(),\n          rowIndex,\n          disabled\n        }\n      });\n    } else {\n      isMounted.current = true;\n    }\n  }, [rowIndex, disabled]);\n\n  // Create a stable callback function for handling key down events:\n  const handleKeyDown = useCallback((event: KeyboardEvent) => {\n    const key = EventKey[event.key];\n    if (!key) {\n      return;\n    }\n    context.dispatch({\n      type: ActionType.KEY_DOWN,\n      payload: { id: getId(), key, ctrlKey: event.ctrlKey }\n    });\n    event.preventDefault();\n  }, []);\n\n  // Create a stable callback function for handling click events:\n  const handleClick = useCallback(() => {\n    context.dispatch({ type: ActionType.CLICKED, payload: { id: getId() } });\n  }, []);\n\n  // Determine if the current tab stop is the currently active one:\n  const selected = getId() === context.state.selectedId;\n\n  const tabIndex = selected ? 0 : -1;\n  const focused = selected && context.state.allowFocusing;\n\n  return [tabIndex, focused, handleKeyDown, handleClick, idRef.current];\n}\n","import { useEffect, RefObject } from \"react\";\n\n/**\n * Focuses on the given DOM element as required.\n * @param {boolean | null | undefined} focused Whether or not\n * the specified DOM element should have focus() invoked on it.\n * @param {RefObject<SVGElement | HTMLElement>} ref The DOM\n * element to control the focus of.\n */\nexport function useFocusEffect(\n  focused: boolean | null | undefined,\n  ref: RefObject<SVGElement | HTMLElement>\n): void {\n  // useLayoutEffect is not required as a focus outline is normally\n  // the browser's default rendering or a custom box shadow. Both\n  // do not affect layout or appearance beyond this outline so\n  // will not cause a jank-like change in appearance when added.\n  useEffect(() => {\n    if (focused && ref.current) {\n      ref.current.focus();\n    }\n  }, [focused]);\n}\n"],"names":["EventKey","Navigation","ActionType","warning","createContext","useReducer","useEffect","useMemo","React","useRef","useContext","useCallback"],"mappings":"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"}